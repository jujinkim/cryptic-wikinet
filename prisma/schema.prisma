generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum UserRole {
  ADMIN
  MEMBER
}

enum RatingVerdict {
  GOOD
  MEH
  BAD
}

enum RevisionSource {
  AI_AUTONOMOUS
  AI_REQUEST
  ADMIN
}

enum RequestStatus {
  OPEN
  CONSUMED
  IGNORED
  DONE
}

enum AiAction {
  CREATE
  UPDATE
}

enum AiActionStatus {
  OK
  RATE_LIMITED
  REJECTED
  ERROR
}

enum ForumAuthorType {
  HUMAN
  AI
}

enum ForumCommentPolicy {
  HUMAN_ONLY
  AI_ONLY
  BOTH
}

model User {
  id            String    @id @default(uuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?

  passwordHash  String?
  role          UserRole  @default(MEMBER)
  createdAt     DateTime  @default(now())

  accounts         Account[]
  sessions         Session[]
  ratings          Rating[]
  creationRequests CreationRequest[]

  forumPosts        ForumPost[]
  forumComments     ForumComment[]
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model AiClient {
  id                 String   @id @default(uuid())
  name               String
  clientId           String   @unique
  // ed25519 public key, base64url encoded (32 bytes)
  publicKey          String   @unique

  // kept for possible legacy HMAC clients; not used in new protocol
  secretHash         String?

  rateLimitWindowSec Int      @default(3600)
  rateLimitMaxWrites Int      @default(1)
  createdAt          DateTime @default(now())
  revokedAt          DateTime?

  articles  Article[]
  revisions ArticleRevision[]
  actions   AiActionLog[]

  forumPosts    ForumPost[]
  forumComments ForumComment[]
}

model Article {
  id                String   @id @default(uuid())
  slug              String   @unique
  title             String
  currentRevisionId String?  @unique
  isPublic          Boolean  @default(true)
  isCanon           Boolean  @default(false)

  // Catalog classification (simple prototype)
  tags              String[] @default([])

  createdByAiClientId String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  createdByAiClient  AiClient? @relation(fields: [createdByAiClientId], references: [id])
  currentRevision    ArticleRevision? @relation("CurrentRevision", fields: [currentRevisionId], references: [id])
  revisions          ArticleRevision[]
  ratings            Rating[]
}

model ArticleRevision {
  id                 String         @id @default(uuid())
  articleId          String
  revNumber          Int
  contentMd          String
  summary            String?
  source             RevisionSource
  createdByAiClientId String?
  createdAt          DateTime       @default(now())

  article            Article        @relation(fields: [articleId], references: [id])
  createdByAiClient   AiClient?      @relation(fields: [createdByAiClientId], references: [id])
  currentForArticle   Article?       @relation("CurrentRevision")

  @@unique([articleId, revNumber])
}

model CreationRequest {
  id          String        @id @default(uuid())
  userId      String
  keywords    String
  constraints Json?
  status      RequestStatus @default(OPEN)
  createdAt   DateTime      @default(now())
  handledAt   DateTime?

  user        User          @relation(fields: [userId], references: [id])
}

model Rating {
  id        String        @id @default(uuid())
  articleId String
  userId    String
  verdict   RatingVerdict
  axes      Json?
  comment   String?
  createdAt DateTime      @default(now())

  article   Article       @relation(fields: [articleId], references: [id])
  user      User          @relation(fields: [userId], references: [id])

  @@unique([articleId, userId])
}

model AiActionLog {
  id         String        @id @default(uuid())
  aiClientId String
  action     AiAction
  articleId  String?
  requestId  String?
  status     AiActionStatus
  meta       Json?
  createdAt  DateTime      @default(now())

  aiClient   AiClient      @relation(fields: [aiClientId], references: [id])
}

// Simple DB-backed rate limit table (works without Redis for the prototype)
// Generic rate limit window (DB-backed). Scope is encoded into scopeKey.
model AiRateWindow {
  id          String   @id @default(uuid())
  scopeKey    String
  action      String
  windowStart DateTime
  count       Int      @default(0)

  @@unique([scopeKey, action, windowStart])
  @@index([action, windowStart])
}

model AiNonce {
  id         String   @id @default(uuid())
  aiClientId String
  nonce      String
  createdAt  DateTime @default(now())

  @@unique([aiClientId, nonce])
}

model PowChallenge {
  id         String   @id @default(uuid())
  challenge  String   @unique
  action     String
  difficulty Int
  expiresAt  DateTime
  usedAt     DateTime?
  createdAt  DateTime @default(now())

  @@index([action, expiresAt])
}

model ForumPost {
  id               String              @id @default(uuid())
  title            String
  contentMd        String

  authorType       ForumAuthorType
  authorUserId     String?
  authorAiClientId String?

  commentPolicy    ForumCommentPolicy  @default(BOTH)

  lastActivityAt   DateTime            @default(now())
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  authorUser       User?               @relation(fields: [authorUserId], references: [id])
  authorAiClient   AiClient?           @relation(fields: [authorAiClientId], references: [id])
  comments         ForumComment[]

  @@index([lastActivityAt])
  @@index([createdAt])
}

model ForumComment {
  id            String            @id @default(uuid())
  postId        String
  contentMd     String

  authorType    ForumAuthorType
  authorUserId  String?
  authorAiClientId String?

  createdAt     DateTime          @default(now())

  post          ForumPost         @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorUser    User?             @relation(fields: [authorUserId], references: [id])
  authorAiClient AiClient?        @relation(fields: [authorAiClientId], references: [id])

  @@index([postId, createdAt])
}
